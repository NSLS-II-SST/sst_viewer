import functools
from widgets import Contour
from bluesky_widgets.models.plot_builders import Images
from bluesky_widgets.models.plot_specs import Figure, Axes

from bluesky_widgets.models.utils import auto_label, call_or_eval, RunManager

class Contours(Images):
    """
    Plot an image from a Run.
    By default, higher-dimensional data is handled by repeatedly averaging over
    the leading dimension until there are only two dimensions.
    Parameters
    ----------
    field : string
        Field name or expression
    max_runs : Integer
        Number of Runs to visualize at once. Default is 1.
    label_maker : Callable, optional
        Expected signature::
            f(run: BlueskyRun, y: String) -> label: String
    needs_streams : List[String], optional
        Streams referred to by field. Default is ``["primary"]``
    namespace : Dict, optional
        Inject additional tokens to be used in expressions for x and y
    axes : Axes, optional
        If None, an axes and figure are created with default labels and titles
        derived from the ``x`` and ``y`` parameters.
    Attributes
    ----------
    max_runs : int
        Number of Runs to visualize at once. This may be changed at any point.
        (Note: Increasing it will not restore any Runs that have already been
        removed, but it will allow more new Runs to be added.) Runs added
        with ``pinned=True`` are exempt from the limit.
    runs : RunList[BlueskyRun]
        As runs are appended entries will be removed from the beginning of the
        last (first in, first out) so that there are at most ``max_runs``.
    pinned : Frozenset[String]
        Run uids of pinned runs.
    figure : Figure
    axes : Axes
    field : String
        Read-only access to field or expression
    needs_streams : List[String], optional
        Read-only access to streams referred to by field.
    namespace : Dict, optional
        Read-only access to user-provided namespace
    Examples
    --------
    >>> model = Images("ccd")
    >>> from bluesky_widgets.jupyter.figures import JupyterFigure
    >>> view = JupyterFigure(model.figure)
    >>> model.add_run(run)
    """

    def __init__(self, x, field, *,
                 max_runs=1,
                 label_maker=None,
                 needs_streams=("primary",),
                 namespace=None,
                 axes=None):

        if label_maker is None:
            # scan_id is always generated by RunEngine but not stricter required by
            # the schema, so we fail gracefully if it is missing.

            def label_maker(run, field):
                md = run.metadata["start"]
                return f"Scan ID {md.get('scan_id', '?')}   UID {md['uid'][:8]}   " f"{auto_label(field)}"

        self._x = x
        self._field = field
        self._label_maker = label_maker
        self._namespace = namespace
        if axes is None:
            axes = Axes()
            figure = Figure((axes,), title="")
        else:
            figure = axes.figure
        self.axes = axes
        self.figure = figure
        # If the Axes' figure is not yet set, listen for it to be set.
        if figure is None:

            def set_figure(event):
                self.figure = event.value
                # This occurs at most once, so we can now stop listening.
                self.axes.events.figure.disconnect(set_figure)

            self.axes.events.figure.connect(set_figure)

        self._run_manager = RunManager(max_runs, needs_streams)
        self._run_manager.events.run_ready.connect(self._add_images)
        self.add_run = self._run_manager.add_run
        self.discard_run = self._run_manager.discard_run

    def _add_images(self, event):
        run = event.run
        func = functools.partial(self._transform, x=self._x, field=self._field)
        image = Contour.from_run(func, run, label=self._field)
        self._run_manager.track_artist(image, [run])
        self.axes.artists.append(image)
        self.axes.title = self._label_maker(run, self._field)
        # TODO Set axes x, y from xarray dims

    def _transform(self, run, x, field):
        def zfun(run):
            """
            May one day do something clever with this
            """
            data = run.primary.read()[f"{field}_spectrum"].data
            xdim = run.start['num_points']
            ydim = data.shape[-1]
            padData = np.zeros((xdim, ydim))
            padData[:data.shape[0], :] = data
            return data

        
        def yfun(run):
            data = run.primary.config[field].read()[f"{field}_energies"].data.squeeze()
            if len(data.shape) > 1:
                try:
                    return data[0, :]
                except:
                    return data
            else:
                return data
        result = call_or_eval({"z": f"{field}_spectrum", "x": x, "y": yfun }, run, self.needs_streams, self.namespace)
        # If the data is more than 2D, take the middle slice from the leading
        # axis until there are only two axes.
        data = result["z"].T
        result["z"] = data
        return result
